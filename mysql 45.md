### mysql 45讲

> #### 第 1 讲

1. server层，包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 
   * 连接器，负责跟客户端建立连接、获取权限、维持和管理连接。 （长连接问题）
   * 查询缓存 ，不推荐使用。
   * 分析器，分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句， MySQL需要识别出里面的字符串分别是什么，代表什么；做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 
   * 优化器，经过了分析器， MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。
     优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时
     候，决定各个表的连接顺序。 
   * 执行器，MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误； 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。  
   
   ```
   在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。
   ```
   
2. 存储引擎，负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、 MyISAM、 Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 





> #### 第 2 讲

1. redo log（重做日志）
   * 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时， InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
   *  InnoDB的redo log是固定大小的 。
   * 有了redo log， InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力
     称为crash-safe 。
   * redo log是InnoDB引擎特有的日志 。
   
2. binlog（归档日志）
   
   * binlog是MySQL的Server层实现的，所有引擎都可以使用（binlog没有crash-safe能力）。
   
3. redo log和binlog区别

   * redo log是InnoDB引擎特有的； binlog是MySQL的Server层实现的，所有引擎都可以使用。
   * redo log是物理日志，记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志，记录的是这
     个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 
   * redo log是循环写的，空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一
     定大小后会切换到下一个，并不会覆盖以前的日志。 

4. update时候的内部流程（update table1 set value = value + 1 where id = 2）

   * 执行器先找引擎取ID=2这一行。 ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在
     的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

   * 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，
     再调用引擎接口写入这行新数据。

   * 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处
     于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

   * 执行器生成这个操作的binlog，并把binlog写入磁盘。

   * 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完
     成。 

   ```
   redo log的写入被拆成了两个步骤： prepare和commit，这就是"两阶段提交"。
   ```



> #### 第 3 讲

1. 事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务（这也是MyISAM被InnoDB取代的重要原因之一）。 

2. ACID，原子性，一致性，隔离性，持久性。

3. 隔离性：为了解决数据库上有多个事务同时执行的时候可能出现脏读（dirty read）、不可重复读（nonrepeatable read）、幻读（phantom read）的问题，就有了隔离级别的概念。SQL标准的事务隔离级别包括：<b>读未提交</b>（read uncommitted）、<b>读提交</b>（read committed）、<b>可重复读</b>（repeatable read）和<b>串行化</b>（serializable ）。 

   * 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
   * 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
   * 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
     当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
   * 串行化，顾名思义是对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。当出现读写锁冲突的时
     候，后访问的事务必须等前一个事务执行完成，才能继续执行。

   ```
   在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是， “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
   Oracle数据库的默认隔离级别其实就是“读提交”。
   ```

   



